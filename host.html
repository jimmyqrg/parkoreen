<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Parkoreen - Map Editor & Game">
    <title>Parkoreen</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2d5a27">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/png/icons/icon-play-32.png" id="favicon-32">
    <link rel="icon" type="image/png" sizes="64x64" href="assets/png/icons/icon-play-64.png" id="favicon-64">
    <link rel="apple-touch-icon" href="assets/png/icons/icon-play-128.png">
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0">
    <style>
        /* Page-specific styles */
        body.game-active {
            overflow: hidden;
        }
    </style>
</head>
<body class="game-active">
    <!-- Game Container -->
    <div id="game-container">
        <div class="game-bg sky"></div>
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- Game HUD (visible during play mode) -->
    <div class="game-hud hidden" id="game-hud">
        <!-- Leave button -->
        <button class="hud-btn" id="hud-leave" style="position: fixed; top: 16px; left: 16px; transform: scaleX(-1);">
            <span class="material-symbols-outlined">logout</span>
        </button>
        
        <!-- Settings button -->
        <button class="hud-btn" id="hud-settings" style="position: fixed; top: 16px; right: 16px;">
            <span class="material-symbols-outlined">settings</span>
        </button>
        
        <!-- Chat button -->
        <button class="hud-btn" id="hud-chat" style="position: fixed; bottom: 16px; left: 16px;">
            <span class="material-symbols-outlined">chat</span>
        </button>
        
        <!-- Players button -->
        <button class="hud-btn" id="hud-players" style="position: fixed; bottom: 16px; right: 16px;">
            <span class="material-symbols-outlined">group</span>
        </button>
        
        <!-- Room code display -->
        <div id="room-code-display" class="hidden" style="position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); padding: 12px 24px; border-radius: 12px; font-family: 'Parkoreen Game', monospace; font-size: 1.5rem; letter-spacing: 6px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); box-shadow: 0 4px 20px rgba(0,0,0,0.5);"></div>
    </div>

    <!-- Players Panel -->
    <div class="players-panel" id="players-panel">
        <div class="panel-header">
            <span class="panel-title">Players</span>
            <button class="btn btn-icon btn-ghost" id="close-players-panel">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        <div class="panel-body" id="players-list">
            <!-- Players will be listed here -->
        </div>
    </div>

    <!-- Chat Panel -->
    <div class="chat-panel" id="chat-panel">
        <div class="chat-messages" id="chat-messages">
            <!-- Chat messages will appear here -->
        </div>
        <div class="chat-input-container">
            <input type="text" class="chat-input" id="chat-input" placeholder="Type a message..." maxlength="200">
            <button class="chat-send" id="chat-send">
                <span class="material-symbols-outlined" style="font-size: 18px;">send</span>
            </button>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="loading-logo">
                <img src="assets/png/logo.png" alt="Parkoreen" style="width: 120px; height: 120px; border-radius: 24px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
            </div>
            <h2 class="loading-title">Loading Parkoreen</h2>
            <div class="loading-progress-container">
                <div class="loading-progress-bar" id="loading-progress-bar"></div>
            </div>
            <div class="loading-status" id="loading-status">Initializing...</div>
            <div class="loading-size" id="loading-size"></div>
        </div>
    </div>
    <style>
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            transition: opacity 0.5s ease;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-content {
            text-align: center;
            color: white;
        }
        .loading-logo {
            margin-bottom: 24px;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .loading-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 24px;
            color: #4ade80;
        }
        .loading-progress-container {
            width: 300px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 auto 16px;
        }
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s ease;
        }
        .loading-status {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            margin-bottom: 8px;
        }
        .loading-size {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
        }
    </style>

    <!-- End Game Screen -->
    <div class="end-game-overlay hidden" id="end-game-overlay">
        <div class="end-game-modal">
            <div class="end-game-trophy">
                <span class="material-symbols-outlined">emoji_events</span>
            </div>
            <h1 class="end-game-title">Level Complete!</h1>
            <div class="end-game-time">
                <span class="end-game-time-label">Your Time</span>
                <span class="end-game-time-value" id="end-game-time">0:00.000</span>
            </div>
            <div class="end-game-player" id="end-game-player">Player Name</div>
            <div class="end-game-actions">
                <button class="btn btn-primary" id="end-game-play-again">
                    <span class="material-symbols-outlined">replay</span>
                    Play Again
                </button>
                <button class="btn btn-secondary" id="end-game-back">
                    <span class="material-symbols-outlined">arrow_back</span>
                    Back to Editor
                </button>
            </div>
        </div>
    </div>

    <!-- Safe wrapper functions with inline fallback (no browser alerts) -->
    <script>
        function showInlineToast(msg, type) {
            var existing = document.getElementById('inline-toast');
            if (existing) existing.remove();
            
            var toast = document.createElement('div');
            toast.id = 'inline-toast';
            toast.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:12px 24px;border-radius:8px;color:#fff;font-weight:500;z-index:99999;animation:fadeIn 0.3s;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:90%;text-align:center;';
            toast.style.background = type === 'error' ? '#e74c3c' : type === 'success' ? '#27ae60' : '#3498db';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(function() { toast.style.opacity = '0'; toast.style.transition = 'opacity 0.3s'; }, 3000);
            setTimeout(function() { if (toast.parentNode) toast.remove(); }, 3500);
        }
        function toastSuccess(msg) {
            console.log('[Toast Success]', msg);
            try {
                if (window.ToastManager && typeof window.ToastManager.show === 'function') {
                    window.ToastManager.show(msg, 'success');
                } else { showInlineToast(msg, 'success'); }
            } catch (e) { showInlineToast(msg, 'success'); }
        }
        function toastError(msg) {
            console.log('[Toast Error]', msg);
            try {
                if (window.ToastManager && typeof window.ToastManager.show === 'function') {
                    window.ToastManager.show(msg, 'error');
                } else { showInlineToast(msg, 'error'); }
            } catch (e) { showInlineToast(msg, 'error'); }
        }
        function loadingShow(msg) {
            try {
                if (window.LoadingManager && typeof window.LoadingManager.show === 'function') {
                    window.LoadingManager.show(msg);
                }
            } catch (e) {}
        }
        function loadingHide() {
            try {
                if (window.LoadingManager && typeof window.LoadingManager.hide === 'function') {
                    window.LoadingManager.hide();
                }
            } catch (e) {}
        }
    </script>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="runtime.js?v=19"></script>
    <script src="assets/js/style.js?v=11"></script>
    <script src="assets/js/game.js?v=12"></script>
    <script src="assets/js/editor.js?v=14"></script>
    <script src="assets/js/exportImport.js?v=12"></script>
    <script>
        // Global state
        let engine;
        let editor;
        let currentMapId = null;
        let currentMode = 'edit'; // 'edit', 'host', 'play'
        let isHost = false;
        let mapLoadedSuccessfully = false; // Track if map loaded properly to prevent saving corrupted/blank data
        
        // Show save corrupted popup
        function showSaveCorruptedPopup() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'save-corrupted-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 99999;
            `;
            
            const popup = document.createElement('div');
            popup.style.cssText = `
                background: #1a1a2e;
                border: 2px solid #ff4444;
                border-radius: 12px;
                padding: 32px;
                max-width: 400px;
                text-align: center;
                font-family: 'Parkoreen UI', sans-serif;
            `;
            
            popup.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">⚠️</div>
                <h2 style="color: #ff4444; margin: 0 0 16px 0; font-size: 24px;">Save Corrupted</h2>
                <p style="color: #aaa; margin: 0 0 24px 0; line-height: 1.5;">
                    The map data could not be loaded. The save file may be corrupted or incompatible.
                </p>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="corrupted-return" style="
                        padding: 12px 24px;
                        background: #333;
                        border: 1px solid #555;
                        color: #fff;
                        border-radius: 8px;
                        cursor: pointer;
                        font-family: inherit;
                        font-size: 14px;
                    ">Return to Menu</button>
                    <button id="corrupted-force" style="
                        padding: 12px 24px;
                        background: #ff4444;
                        border: none;
                        color: #fff;
                        border-radius: 8px;
                        cursor: pointer;
                        font-family: inherit;
                        font-size: 14px;
                    ">Force Enter</button>
                </div>
            `;
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Event listeners
            document.getElementById('corrupted-return').addEventListener('click', () => {
                window.location.href = 'dashboard/';
            });
            
            document.getElementById('corrupted-force').addEventListener('click', () => {
                overlay.remove();
                mapLoadedSuccessfully = true; // Allow saving now
                toastSuccess('Entered with empty map. Changes will be saved.');
            });
        }

        // Helper to change favicon based on mode
        function setFavicon(type) {
            // type: 'play', 'editor'
            const favicon32 = document.getElementById('favicon-32');
            const favicon64 = document.getElementById('favicon-64');
            if (favicon32) favicon32.href = `assets/png/icons/icon-${type}-32.png`;
            if (favicon64) favicon64.href = `assets/png/icons/icon-${type}-64.png`;
        }

        // Resource Loader
        class ResourceLoader {
            constructor() {
                this.totalBytes = 0;
                this.loadedBytes = 0;
                this.resources = [];
            }
            
            updateProgress(status) {
                const progressBar = document.getElementById('loading-progress-bar');
                const statusEl = document.getElementById('loading-status');
                const sizeEl = document.getElementById('loading-size');
                
                if (progressBar && this.resources.length > 0) {
                    const percent = Math.min(100, (this.loadedBytes / Math.max(1, this.totalBytes)) * 100);
                    progressBar.style.width = percent + '%';
                }
                if (statusEl && status) {
                    statusEl.textContent = status;
                }
                if (sizeEl && this.totalBytes > 0) {
                    const loaded = this.formatBytes(this.loadedBytes);
                    const total = this.formatBytes(this.totalBytes);
                    sizeEl.textContent = `${loaded} / ${total}`;
                }
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
            
            async preloadImage(src) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        this.loadedBytes += 50000; // Estimate ~50KB per image
                        this.updateProgress('Loading images...');
                        resolve(img);
                    };
                    img.onerror = () => resolve(null);
                    img.src = src;
                });
            }
            
            async preloadAudio(src) {
                return new Promise((resolve) => {
                    const audio = new Audio();
                    audio.oncanplaythrough = () => {
                        this.loadedBytes += 500000; // Estimate ~500KB per audio
                        this.updateProgress('Loading audio...');
                        resolve(audio);
                    };
                    audio.onerror = () => resolve(null);
                    audio.src = src;
                });
            }
            
            async preloadScript(src) {
                return new Promise((resolve) => {
                    // Scripts are already loaded, just track
                    this.loadedBytes += 100000; // Estimate ~100KB per script
                    this.updateProgress('Loading scripts...');
                    resolve();
                });
            }
            
            async loadAll() {
                this.updateProgress('Preparing resources...');
                
                // List of resources to preload
                const images = [
                    'assets/png/logo.png',
                    'assets/png/spike-64x.svg',
                    'assets/png/spike-512x.svg',
                    'assets/png/icons/icon-play-512.png'
                ];
                
                const audio = [
                    'assets/mp3/jump.mp3',
                    'assets/mp3/death.mp3',
                    'assets/mp3/checkpoint.mp3',
                    'assets/mp3/finish.mp3',
                    'assets/mp3/maccary-bay.mp3',
                    'assets/mp3/reggae-party.mp3'
                ];
                
                // Estimate total size
                this.totalBytes = (images.length * 50000) + (audio.length * 500000) + 400000; // +400KB for scripts
                this.updateProgress('Loading resources...');
                
                // Preload images
                for (const src of images) {
                    await this.preloadImage(src);
                }
                
                // Preload audio (in parallel for speed)
                this.updateProgress('Loading audio...');
                await Promise.all(audio.map(src => this.preloadAudio(src)));
                
                // Mark scripts as loaded
                this.loadedBytes += 400000;
                this.updateProgress('Finalizing...');
                
                return true;
            }
            
            hide() {
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.classList.add('hidden');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 500);
                }
            }
        }
        
        const resourceLoader = new ResourceLoader();

        document.addEventListener('DOMContentLoaded', async () => {
            // Check auth
            if (!Auth.requireAuth()) return;

            // Parse URL params
            const params = new URLSearchParams(window.location.search);
            currentMapId = params.get('map');
            currentMode = params.get('mode') || 'edit';
            const roomCode = params.get('room');
            
            // Preload resources first
            resourceLoader.updateProgress('Loading resources...');
            await resourceLoader.loadAll();

            // Initialize game engine
            resourceLoader.updateProgress('Initializing game engine...');
            engine = new GameEngine('game-canvas');
            engine.start();

            // Initialize editor
            resourceLoader.updateProgress('Setting up editor...');
            editor = new Editor(engine);
            editor.initUI();
            editor.updateBackground();
            
            // Create editor player (fly mode, camera follows, no death)
            engine.createEditorPlayer();
            
            // Set initial favicon based on mode
            if (currentMode === 'edit') {
                setFavicon('editor');
            } else {
                setFavicon('play');
            }

            // Load map or game data
            if (currentMode === 'play' && roomCode) {
                // Join existing game
                resourceLoader.updateProgress('Joining game...');
                await initializePlayMode(roomCode);
            } else if (currentMapId) {
                // Load map for editing or hosting
                resourceLoader.updateProgress('Loading map data...');
                await loadMap(currentMapId);
                
                if (currentMode === 'host') {
                    // Directly start hosting after map is loaded
                    setTimeout(() => {
                        if (editor && editor.hostGame) {
                            editor.hostGame();
                        }
                    }, 500);
                }
            } else {
                // New map - no existing data to corrupt
                engine.world.mapName = 'New Map';
                mapLoadedSuccessfully = true;
            }

            // Setup event handlers
            setupGameHUD();
            setupMultiplayer();
            setupEndGameScreen();
            
            // Setup auto-save for editor mode
            if (currentMapId) {
                console.log('[AutoSave] Setting up auto-save for map:', currentMapId);
                
                // Auto-save every 30 seconds
                setInterval(async () => {
                    if (engine && engine.state === GameState.EDITOR) {
                        console.log('[AutoSave] Interval save (30s)...');
                        await saveMap();
                    }
                }, 30000);
                
                // Setup save-on-change callback
                editor.onMapChange = debounce(async () => {
                    if (engine && engine.state === GameState.EDITOR) {
                        console.log('[AutoSave] Change detected, saving...');
                        await saveMapSilent();
                    }
                }, 2000); // Debounce: wait 2 seconds after last change before saving
                
                // Setup save-before-test callback
                editor.onBeforeTest = async () => {
                    console.log('[AutoSave] Saving before test...');
                    await saveMapSilent();
                };
            }
            
            // Hide loading screen after everything is ready
            resourceLoader.updateProgress('Ready!');
            setTimeout(() => {
                resourceLoader.hide();
            }, 300);
        });
        
        // Silent save (no toast) for auto-save on change
        async function saveMapSilent() {
            if (!currentMapId) return;
            if (!mapLoadedSuccessfully) {
                console.warn('[AutoSave] Skipping save - map was not loaded successfully');
                return;
            }
            try {
                const data = engine.world.toJSON();
                var saveFn = window.MapManager.saveMap;
                await saveFn.call(window.MapManager, currentMapId, { data });
                console.log('[AutoSave] Saved silently');
            } catch (error) {
                console.error('[AutoSave] Silent save failed:', error);
            }
        }
        
        // Debounce utility
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        async function loadMap(mapId) {
            let mapData = null;
            
            // Step 1: Try to fetch the map from storage
            try {
                loadingShow('Loading map...');
                var getMapFn = window.MapManager.getMap;
                mapData = await getMapFn.call(window.MapManager, mapId);
            } catch (networkError) {
                // Network error - don't allow saving to prevent data loss
                loadingHide();
                mapLoadedSuccessfully = false;
                toastError('Failed to load map (network error): ' + networkError.message);
                console.error('[LoadMap] Network error, saving disabled:', networkError);
                return;
            }
            
            // Step 2: Try to parse/deserialize the map data
            try {
                if (mapData && mapData.data) {
                    engine.world.fromJSON(mapData.data);
                }
                engine.world.mapName = mapData?.name || 'Untitled Map';
                
                // Recreate editor player at spawn point
                engine.createEditorPlayer();
                
                editor.updateBackground();
                loadingHide();
                
                // Map loaded successfully - allow saving
                mapLoadedSuccessfully = true;
                toastSuccess('Map loaded!');
            } catch (parseError) {
                // Parse/corruption error - show popup
                loadingHide();
                mapLoadedSuccessfully = false;
                console.error('[LoadMap] Save corrupted:', parseError);
                showSaveCorruptedPopup();
            }
        }

        async function saveMap() {
            if (!currentMapId) {
                toastError('No map to save');
                return;
            }
            
            if (!mapLoadedSuccessfully) {
                console.warn('[SaveMap] Skipping save - map was not loaded successfully');
                toastError('Cannot save: map failed to load properly');
                return;
            }

            try {
                const data = engine.world.toJSON();
                var saveFn = window.MapManager.saveMap;
                await saveFn.call(window.MapManager, currentMapId, { data });
                toastSuccess('Map saved!');
            } catch (error) {
                toastError('Failed to save map: ' + error.message);
            }
        }

        async function initializePlayMode(roomCode) {
            const gameData = sessionStorage.getItem('parkoreen_game');
            if (gameData) {
                const data = JSON.parse(gameData);
                if (data.mapData) {
                    engine.world.fromJSON(data.mapData);
                    // Update background based on map theme
                    editor.updateBackground();
                }
                isHost = data.isHost || false;
            }

            // Hide editor UI
            document.getElementById('editor-ui')?.classList.add('hidden');
            document.getElementById('toolbar')?.classList.add('hidden');

            // Show game HUD
            document.getElementById('game-hud').classList.remove('hidden');
            
            // Show room code
            if (roomCode) {
                const roomCodeDisplay = document.getElementById('room-code-display');
                roomCodeDisplay.innerHTML = '<span style="font-size: 0.9rem; opacity: 0.8; letter-spacing: 1px;">Game Code:</span> ' + roomCode;
                roomCodeDisplay.classList.remove('hidden');
            }

            // Start game with user's persistent color
            const user = Auth.getUser();
            engine.startGame(user.name, user.color);

            // Setup touch controls if enabled
            if (Settings.get('touchscreenMode')) {
                editor.updateTouchControls();
            }
            
            // Start music playback
            if (editor && editor.startMusicPlayback) {
                editor.startMusicPlayback();
            }

            // Reconnect to multiplayer for this room
            await reconnectToRoom(roomCode);
            
            // Start position update loop
            startPositionUpdates();
        }
        
        async function reconnectToRoom(roomCode) {
            const mp = window.MultiplayerManager;
            if (!mp) {
                console.log('[Play] MultiplayerManager not available');
                return;
            }
            
            try {
                // Connect to WebSocket
                await mp.connect();
                
                // Wait for authentication
                await mp.waitForAuth();
                
                console.log('[Play] Reconnected to multiplayer, rejoining room:', roomCode);
                
                // Rejoin the room (server should recognize this session)
                mp.send({
                    type: 'rejoin_room',
                    roomCode: roomCode
                });
            } catch (error) {
                console.error('[Play] Failed to reconnect:', error);
                toastError('Failed to connect to multiplayer: ' + error.message);
            }
        }
        
        function startPositionUpdates() {
            setInterval(() => {
                const mp = window.MultiplayerManager;
                if (engine.localPlayer && mp && mp.sendPosition && currentMode === 'play') {
                    mp.sendPosition(
                        engine.localPlayer.x, 
                        engine.localPlayer.y,
                        engine.localPlayer.vx || 0,
                        engine.localPlayer.vy || 0
                    );
                }
            }, 50); // 20 updates per second
        }

        function setupGameHUD() {
            // Leave button
            document.getElementById('hud-leave').addEventListener('click', async () => {
                if (isHost) {
                    let confirmed = false;
                    try {
                        if (window.ModalManager && typeof window.ModalManager.confirm === 'function') {
                            confirmed = await window.ModalManager.confirm(
                                'Leave Room',
                                'Are you sure you want to kick everybody in the room?'
                            );
                        } else {
                            confirmed = confirm('Are you sure you want to kick everybody in the room?');
                        }
                    } catch (e) {
                        confirmed = confirm('Are you sure you want to kick everybody in the room?');
                    }
                    
                    if (confirmed) {
                        if (window.MultiplayerManager?.leaveRoom) {
                            window.MultiplayerManager.leaveRoom();
                        }
                        Navigation.toDashboard();
                    }
                } else {
                    if (window.MultiplayerManager?.leaveRoom) {
                        window.MultiplayerManager.leaveRoom();
                    }
                    Navigation.toDashboard();
                }
            });

            // Settings button
            document.getElementById('hud-settings').addEventListener('click', () => {
                document.getElementById('settings-panel')?.classList.toggle('active');
            });

            // Chat button
            document.getElementById('hud-chat').addEventListener('click', () => {
                document.getElementById('chat-panel').classList.toggle('active');
            });

            // Players button
            document.getElementById('hud-players').addEventListener('click', () => {
                document.getElementById('players-panel').classList.toggle('active');
                updatePlayersList();
            });

            // Close panels
            document.getElementById('close-players-panel').addEventListener('click', () => {
                document.getElementById('players-panel').classList.remove('active');
            });

            // Chat send
            document.getElementById('chat-send').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
        }

        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (message) {
                if (window.MultiplayerManager?.sendChatMessage) {
                    window.MultiplayerManager.sendChatMessage(message);
                }
                input.value = '';
            }
        }

        function addChatMessage(name, message, color) {
            const container = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message';
            messageEl.innerHTML = `
                <span class="chat-message-name" style="color: ${color || '#fff'};">${escapeHtml(name)}:</span>
                <span>${escapeHtml(message)}</span>
            `;
            container.appendChild(messageEl);
            container.scrollTop = container.scrollHeight;
        }

        function updatePlayersList() {
            const container = document.getElementById('players-list');
            const players = window.MultiplayerManager?.getPlayers?.() || [];
            
            container.innerHTML = '';
            
            players.forEach(player => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <div class="player-color" style="background: ${player.color}"></div>
                    <span class="player-name">${escapeHtml(player.name)}</span>
                    ${isHost ? `
                        <button class="layer-btn" data-kick="${player.id}" title="Kick Player">
                            <span class="material-symbols-outlined">person_remove</span>
                        </button>
                    ` : ''}
                `;

                if (isHost) {
                    item.querySelector('[data-kick]')?.addEventListener('click', () => {
                        if (window.MultiplayerManager?.kickPlayer) {
                            window.MultiplayerManager.kickPlayer(player.id);
                        }
                    });
                }

                container.appendChild(item);
            });
        }

        function setupMultiplayer() {
            // Check if MultiplayerManager is available
            const mp = window.MultiplayerManager;
            if (!mp || typeof mp.on !== 'function') {
                console.log('[Multiplayer] MultiplayerManager not available, skipping setup');
                return;
            }
            
            // Player joined
            mp.on('playerJoined', (data) => {
                engine.addRemotePlayer(data.playerId, data.playerName, data.playerColor, 0, 0);
                addChatMessage('System', `${data.playerName} joined the parky!`, '#4CAF50');
                updatePlayersList();
            });

            // Player left
            mp.on('playerLeft', (data) => {
                engine.removeRemotePlayer(data.playerId);
                addChatMessage('System', `${data.playerName} left the parky.`, '#f44336');
                updatePlayersList();
            });

            // Player position update
            mp.on('playerPosition', (data) => {
                engine.updateRemotePlayer(data.playerId, data.x, data.y, data.vx || 0, data.vy || 0);
            });

            // Chat message
            mp.on('chatMessage', (data) => {
                addChatMessage(data.playerName, data.message, data.playerColor);
            });

            // Kicked
            mp.on('kicked', async () => {
                await ModalManager.alert('You Are Kicked!', "Looks like the host doesn't want you to be in here anymore :(");
                Navigation.toDashboard();
            });

            // Room closed
            mp.on('roomClosed', async () => {
                await ModalManager.alert('Uh Oh', 'The host has left the parky :(');
                Navigation.toDashboard();
            });

            // Game end
            mp.on('gameEnd', (data) => {
                ModalManager.alert('Game Over!', `${data.winnerName} has reached the finish line!`);
            });
            
            // Room rejoined (after page reload)
            mp.on('roomRejoined', (data) => {
                console.log('[Multiplayer] Rejoined room:', data.roomCode);
                isHost = data.isHost;
                // Add existing players to the game
                if (data.players) {
                    data.players.forEach(p => {
                        engine.addRemotePlayer(p.id, p.name, p.color, 0, 0);
                    });
                }
                updatePlayersList();
                toastSuccess('Reconnected to room!');
            });
        }

        // Override editor's host game function
        if (typeof Editor !== 'undefined') {
            Editor.prototype.hostGame = async function() {
                // Validate
                if (!this.world.spawnPoint) {
                    this.showToast('Please add a spawn point first!', 'error');
                    return;
                }

                const usePassword = document.getElementById('config-use-password').checked;
                const password = document.getElementById('config-password').value;
                const maxPlayers = parseInt(document.getElementById('config-max-players')?.value) || 10;

                if (usePassword && !password) {
                    this.showToast('Please enter a password or disable password protection.', 'error');
                    return;
                }

                try {
                    loadingShow('Creating room...');

                    // Save map first
                    if (currentMapId) {
                        await saveMap();
                    }

                    const mapData = this.world.toJSON();
                    const mp = window.MultiplayerManager;
                    
                    if (!mp) {
                        throw new Error('Multiplayer not available');
                    }

                    // Setup event handlers before hosting
                    mp.on('roomCreated', (data) => {
                        loadingHide();
                        console.log('[Host] Room created:', data.roomCode);
                        
                        // Store game data in session storage
                        sessionStorage.setItem('parkoreen_game', JSON.stringify({
                            roomCode: data.roomCode,
                            mapData: mapData,
                            isHost: true
                        }));
                        
                        // Enter play mode
                        startHostedGame(data.roomCode, mapData);
                    });

                    mp.on('error', (data) => {
                        loadingHide();
                        toastError('Failed to create room: ' + data.message);
                    });

                    // Create room on server
                    await mp.hostGame({
                        mapData: mapData,
                        maxPlayers: maxPlayers,
                        usePassword: usePassword,
                        password: usePassword ? password : null
                    });
                    
                } catch (error) {
                    loadingHide();
                    toastError('Failed to host game: ' + error.message);
                }
            };
        }
        
        // Start a hosted game session
        async function startHostedGame(roomCode, mapData) {
            currentMode = 'play';
            isHost = true;
            
            // Switch to play icon
            setFavicon('play');
            
            // Hide editor UI
            document.getElementById('editor-ui')?.classList.add('hidden');
            document.getElementById('toolbar')?.classList.add('hidden');
            
            // Close config panel
            editor.closePanel('config');
            
            // Show game HUD
            document.getElementById('game-hud').classList.remove('hidden');
            
            // Show room code display
            const roomCodeDisplay = document.getElementById('room-code-display');
            roomCodeDisplay.innerHTML = '<span style="font-size: 0.9rem; opacity: 0.8; letter-spacing: 1px;">Game Code:</span> ' + roomCode;
            roomCodeDisplay.classList.remove('hidden');
            
            // Start the game with user's persistent color
            const user = Auth.getUser();
            engine.startGame(user.name, user.color);
            
            // Setup touch controls if enabled
            if (Settings.get('touchscreenMode')) {
                editor.updateTouchControls();
            }
            
            // Start music playback
            if (editor && editor.startMusicPlayback) {
                editor.startMusicPlayback();
            }
            
            // Start sending position updates
            startPositionUpdates();
            
            toastSuccess('Room created! Share the code: ' + roomCode);
        }

        // Save on page visibility change (user switches tabs)
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && currentMapId && engine && engine.state === GameState.EDITOR) {
                console.log('[AutoSave] Tab hidden, saving...');
                await saveMap();
            }
        });

        // Save on page unload (user closes tab or navigates away)
        window.addEventListener('beforeunload', (e) => {
            if (currentMapId && engine && engine.state === GameState.EDITOR && mapLoadedSuccessfully) {
                // Use synchronous save for local mode
                try {
                    const data = engine.world.toJSON();
                    // Try to save synchronously to local storage
                    const maps = JSON.parse(localStorage.getItem('parkoreen_local_maps_' + (Auth.getUser()?.id || 'guest')) || '{}');
                    if (maps[currentMapId]) {
                        maps[currentMapId].data = data;
                        maps[currentMapId].updatedAt = new Date().toISOString();
                        localStorage.setItem('parkoreen_local_maps_' + (Auth.getUser()?.id || 'guest'), JSON.stringify(maps));
                        console.log('[AutoSave] Saved on unload');
                    }
                } catch (err) {
                    console.error('[AutoSave] Failed to save on unload:', err);
                }
            } else if (currentMapId && !mapLoadedSuccessfully) {
                console.warn('[AutoSave] Skipping unload save - map was not loaded successfully');
            }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        let lastEndGameData = null;

        function setupEndGameScreen() {
            // Set up the game end callback
            engine.onGameEndCallback = (data) => {
                showEndGameScreen(data);
                
                // If in multiplayer, notify other players
                if (window.MultiplayerManager && window.MultiplayerManager.send && currentMode === 'play') {
                    window.MultiplayerManager.send({
                        type: 'game_end',
                        playerName: data.playerName,
                        time: data.time
                    });
                }
            };

            // Play Again button
            document.getElementById('end-game-play-again').addEventListener('click', () => {
                hideEndGameScreen();
                
                // Restart the game
                if (lastEndGameData && lastEndGameData.wasTestMode) {
                    // Restart test mode
                    engine.startTestGame();
                    if (editor && editor.startMusicPlayback) {
                        editor.startMusicPlayback();
                    }
                } else {
                    // Restart play mode
                    const user = Auth.getUser();
                    engine.startGame(user.name, user.color);
                    if (editor && editor.startMusicPlayback) {
                        editor.startMusicPlayback();
                    }
                }
            });

            // Back to Editor button
            document.getElementById('end-game-back').addEventListener('click', () => {
                hideEndGameScreen();
                
                if (currentMode === 'play') {
                    // Leave the multiplayer room
                    if (window.MultiplayerManager?.leaveRoom) {
                        window.MultiplayerManager.leaveRoom();
                    }
                    Navigation.toDashboard();
                } else {
                    // Stop testing and return to editor
                    editor.stopTest();
                }
            });
        }
        
        function showEndGameScreen(data) {
            lastEndGameData = data;
            const overlay = document.getElementById('end-game-overlay');
            const timeValue = document.getElementById('end-game-time');
            const playerName = document.getElementById('end-game-player');
            const backBtn = document.getElementById('end-game-back');
            
            // Set the time
            timeValue.textContent = data.time || '0:00.000';
            
            // Set player name
            playerName.textContent = data.playerName || 'Player';
            
            // Update button text based on mode
            if (data.wasTestMode) {
                backBtn.innerHTML = '<span class="material-symbols-outlined">edit</span> Back to Editor';
            } else {
                backBtn.innerHTML = '<span class="material-symbols-outlined">arrow_back</span> Leave Game';
            }
            
            // Show the overlay
            overlay.classList.remove('hidden');
        }

        function hideEndGameScreen() {
            const overlay = document.getElementById('end-game-overlay');
            overlay.classList.add('hidden');
        }
    </script>
</body>
</html>
