<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Parkoreen - Map Editor & Game">
    <title>Parkoreen</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2d5a27">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/png/icons/icon-play-32.png" id="favicon-32">
    <link rel="icon" type="image/png" sizes="64x64" href="assets/png/icons/icon-play-64.png" id="favicon-64">
    <link rel="apple-touch-icon" href="assets/png/icons/icon-play-128.png">
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0">
    <style>
        /* Page-specific styles */
        body.game-active {
            overflow: hidden;
        }
    </style>
</head>
<body class="game-active">
    <!-- Game Container -->
    <div id="game-container">
        <div class="game-bg sky"></div>
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- Game HUD (visible during play mode) -->
    <div class="game-hud hidden" id="game-hud">
        <!-- Leave button -->
        <button class="hud-btn" id="hud-leave" style="position: fixed; top: 16px; left: 16px; transform: scaleX(-1);">
            <span class="material-symbols-outlined">logout</span>
        </button>
        
        <!-- Settings button -->
        <button class="hud-btn" id="hud-settings" style="position: fixed; top: 16px; right: 16px;">
            <span class="material-symbols-outlined">settings</span>
        </button>
        
        <!-- Chat button -->
        <button class="hud-btn" id="hud-chat" style="position: fixed; bottom: 16px; left: 16px;">
            <span class="material-symbols-outlined">chat</span>
        </button>
        
        <!-- Players button -->
        <button class="hud-btn" id="hud-players" style="position: fixed; bottom: 16px; right: 16px;">
            <span class="material-symbols-outlined">group</span>
        </button>
        
        <!-- Room code display -->
        <div id="room-code-display" class="hidden" style="position: fixed; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); padding: 12px 24px; border-radius: 12px; font-family: 'Parkoreen Game', monospace; font-size: 1.5rem; letter-spacing: 6px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); box-shadow: 0 4px 20px rgba(0,0,0,0.5);"></div>
    </div>

    <!-- Players Panel -->
    <div class="players-panel" id="players-panel">
        <div class="panel-header">
            <span class="panel-title">Players</span>
            <button class="btn btn-icon btn-ghost" id="close-players-panel">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        <div class="panel-body" id="players-list">
            <!-- Players will be listed here -->
        </div>
    </div>

    <!-- Chat Panel -->
    <div class="chat-panel" id="chat-panel">
        <div class="chat-messages" id="chat-messages">
            <!-- Chat messages will appear here -->
        </div>
        <div class="chat-input-container">
            <input type="text" class="chat-input" id="chat-input" placeholder="Type a message..." maxlength="200">
            <button class="chat-send" id="chat-send">
                <span class="material-symbols-outlined" style="font-size: 18px;">send</span>
            </button>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-content">
            <div class="loading-logo">
                <img src="assets/png/logo.png" alt="Parkoreen" style="width: 120px; height: 120px; border-radius: 24px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
            </div>
            <h2 class="loading-title">Loading Parkoreen</h2>
            
            <!-- Total Progress (Green) -->
            <div class="loading-label" id="loading-label-total">Total Progress</div>
            <div class="loading-progress-container">
                <div class="loading-progress-bar loading-progress-green" id="loading-progress-total"></div>
            </div>
            <div class="loading-size" id="loading-size-total"></div>
            
            <!-- Part Progress (Orange) -->
            <div class="loading-label" id="loading-label-part" style="margin-top: 16px;">Current: Initializing...</div>
            <div class="loading-progress-container">
                <div class="loading-progress-bar loading-progress-orange" id="loading-progress-part"></div>
            </div>
            <div class="loading-size" id="loading-size-part"></div>
            
            <!-- Hints -->
            <div class="loading-hint" id="loading-hint"></div>
        </div>
    </div>
    <style>
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            transition: opacity 0.5s ease;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-content {
            text-align: center;
            color: white;
        }
        .loading-logo {
            margin-bottom: 24px;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .loading-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #4ade80;
        }
        .loading-label {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.8);
            margin-bottom: 8px;
            font-weight: 500;
        }
        .loading-progress-container {
            width: 300px;
            height: 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            overflow: hidden;
            margin: 0 auto 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .loading-progress-bar {
            height: 100%;
            border-radius: 5px;
            width: 0%;
            background-size: 200% 100%;
            animation: shimmer 1.5s ease-in-out infinite;
            transition: width 0.15s ease-out;
        }
        .loading-progress-green {
            background: linear-gradient(90deg, #22c55e, #4ade80, #22c55e);
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5), 0 0 20px rgba(74, 222, 128, 0.3);
        }
        .loading-progress-orange {
            background: linear-gradient(90deg, #ea580c, #fb923c, #ea580c);
            box-shadow: 0 0 10px rgba(251, 146, 60, 0.5), 0 0 20px rgba(251, 146, 60, 0.3);
        }
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        .loading-size {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 4px;
        }
        .loading-hint {
            margin-top: 28px;
            padding: 16px 24px;
            max-width: 340px;
            font-size: 0.85rem;
            color: rgba(255,255,255,0.7);
            font-style: italic;
            line-height: 1.5;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            border-left: 3px solid #4ade80;
            text-align: left;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        .loading-hint.fade-out {
            opacity: 0;
        }
    </style>

    <!-- End Game Screen -->
    <div class="end-game-overlay hidden" id="end-game-overlay">
        <div class="end-game-modal">
            <div class="end-game-trophy">
                <span class="material-symbols-outlined">emoji_events</span>
            </div>
            <h1 class="end-game-title">Level Complete!</h1>
            <div class="end-game-time">
                <span class="end-game-time-label">Your Time</span>
                <span class="end-game-time-value" id="end-game-time">0:00.000</span>
            </div>
            <div class="end-game-player" id="end-game-player">Player Name</div>
            <div class="end-game-actions">
                <button class="btn btn-primary" id="end-game-play-again">
                    <span class="material-symbols-outlined">replay</span>
                    Play Again
                </button>
                <button class="btn btn-secondary" id="end-game-back">
                    <span class="material-symbols-outlined">arrow_back</span>
                    Back to Editor
                </button>
            </div>
        </div>
    </div>

    <!-- Safe wrapper functions with inline fallback (no browser alerts) -->
    <script>
        function showInlineToast(msg, type) {
            var existing = document.getElementById('inline-toast');
            if (existing) existing.remove();
            
            var toast = document.createElement('div');
            toast.id = 'inline-toast';
            toast.style.cssText = 'position:fixed;top:20px;left:50%;transform:translateX(-50%);padding:12px 24px;border-radius:8px;color:#fff;font-weight:500;z-index:99999;animation:fadeIn 0.3s;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:90%;text-align:center;';
            toast.style.background = type === 'error' ? '#e74c3c' : type === 'success' ? '#27ae60' : '#3498db';
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(function() { toast.style.opacity = '0'; toast.style.transition = 'opacity 0.3s'; }, 3000);
            setTimeout(function() { if (toast.parentNode) toast.remove(); }, 3500);
        }
        function toastSuccess(msg) {
            console.log('[Toast Success]', msg);
            try {
                if (window.ToastManager && typeof window.ToastManager.show === 'function') {
                    window.ToastManager.show(msg, 'success');
                } else { showInlineToast(msg, 'success'); }
            } catch (e) { showInlineToast(msg, 'success'); }
        }
        function toastError(msg) {
            console.log('[Toast Error]', msg);
            try {
                if (window.ToastManager && typeof window.ToastManager.show === 'function') {
                    window.ToastManager.show(msg, 'error');
                } else { showInlineToast(msg, 'error'); }
            } catch (e) { showInlineToast(msg, 'error'); }
        }
        function loadingShow(msg) {
            try {
                if (window.LoadingManager && typeof window.LoadingManager.show === 'function') {
                    window.LoadingManager.show(msg);
                }
            } catch (e) {}
        }
        function loadingHide() {
            try {
                if (window.LoadingManager && typeof window.LoadingManager.hide === 'function') {
                    window.LoadingManager.hide();
                }
            } catch (e) {}
        }
    </script>
    
    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="runtime.js?v=19"></script>
    <script src="assets/js/style.js?v=11"></script>
    <script src="assets/js/plugins.js?v=1"></script>
    <script src="assets/js/game.js?v=13"></script>
    <script src="assets/js/editor.js?v=14"></script>
    <script src="assets/js/exportImport.js?v=12"></script>
    <script>
        // Global state
        let engine;
        let editor;
        let currentMapId = null;
        let currentMode = 'edit'; // 'edit', 'host', 'play'
        let isHost = false;
        let mapLoadedSuccessfully = false; // Track if map loaded properly to prevent saving corrupted/blank data
        
        // Show save corrupted popup
        function showSaveCorruptedPopup() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'save-corrupted-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 99999;
            `;
            
            const popup = document.createElement('div');
            popup.style.cssText = `
                background: #1a1a2e;
                border: 2px solid #ff4444;
                border-radius: 12px;
                padding: 32px;
                max-width: 400px;
                text-align: center;
                font-family: 'Parkoreen UI', sans-serif;
            `;
            
            popup.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                <h2 style="color: #ff4444; margin: 0 0 16px 0; font-size: 24px;">Save Corrupted</h2>
                <p style="color: #aaa; margin: 0 0 24px 0; line-height: 1.5;">
                    The map data could not be loaded. The save file may be corrupted or incompatible.
                </p>
                <div style="display: flex; gap: 12px; justify-content: center;">
                    <button id="corrupted-return" style="
                        padding: 12px 24px;
                        background: #333;
                        border: 1px solid #555;
                        color: #fff;
                        border-radius: 8px;
                        cursor: pointer;
                        font-family: inherit;
                        font-size: 14px;
                    ">Return to Menu</button>
                    <button id="corrupted-force" style="
                        padding: 12px 24px;
                        background: #ff4444;
                        border: none;
                        color: #fff;
                        border-radius: 8px;
                        cursor: pointer;
                        font-family: inherit;
                        font-size: 14px;
                    ">Force Enter</button>
                </div>
            `;
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Event listeners
            document.getElementById('corrupted-return').addEventListener('click', () => {
                window.location.href = 'dashboard/';
            });
            
            document.getElementById('corrupted-force').addEventListener('click', () => {
                overlay.remove();
                mapLoadedSuccessfully = true; // Allow saving now
                toastSuccess('Entered with empty map. Changes will be saved.');
            });
        }

        // Helper to change favicon based on mode
        function setFavicon(type) {
            // type: 'play', 'editor'
            const favicon32 = document.getElementById('favicon-32');
            const favicon64 = document.getElementById('favicon-64');
            if (favicon32) favicon32.href = `assets/png/icons/icon-${type}-32.png`;
            if (favicon64) favicon64.href = `assets/png/icons/icon-${type}-64.png`;
        }

        // Loading hints
        const loadingHints = [
            "Did you know that if you spam left and right on a checkpoint, you get more jumps?",
            "Don't name yourself JimmyQrg, I dare you.",
            "I hate the 5 Pantheon. What? I'm not in Hollow Knight? Ah..",
            "If you set the spike touchbox to Tip Spike, you can walk through them. Don't fall on them though.",
            "Press R to activate the rotate tool. Click and drag to spin objects!",
            "Teleportals only work when both ends are connected. Check your Send To and Receive From settings!",
            "You can flip objects horizontally in the config panel. Great for symmetrical designs!",
            "The eraser tool (Q) can have custom width and height. Big eraser = big destruction.",
            "Custom backgrounds can really set the mood. Try uploading your own!",
            "Drop Hurt Only spikes are perfect for one-way passages.",
            "Zones are invisible during gameplay. Use them for kill zones or special effects!",
            "You can adjust the font size in settings. Squint no more!",
            "The inspect box in test mode shows all object properties. Debug like a pro!",
            "Music keeps playing between editor and test mode. Vibe while you build!",
            "Ctrl+Scroll to zoom in editor mode. Ctrl+Shift+Scroll to reset zoom.",
            "Text objects pass right through players. Use them for signs and decorations!",
            "The loading screen has hints. Oh wait, you're reading one right now...",
            "Hosting a game? Share the room code with friends to play together!",
            "Your player color is unique to your account. Stand out in multiplayer!",
            "Export your map as a .pkrn file to share with others.",
            "Import maps from files to play community creations!",
            "Gravity can be adjusted in config. Try negative gravity for ceiling runners!",
            "Jump height and movement speed are customizable per map.",
            "Additional airjump lets you jump even when not touching the ground.",
            "Touch controls include a virtual joystick. Great for mobile play!",
            "As the host, you can kick players who aren't playing nice.",
            "Your best times are displayed when you complete a level. Speed run!",
            "Layers help organize complex maps. Use them wisely!",
            "Custom music supports MP3 files. Add your favorite tunes!",
            "Invalid teleportal connections appear red. Fix them to enable teleportation!",
            "Fly mode in test mode lets you explore without restrictions.",
            "Ground jumps vs air jumps matter when additional airjump is disabled.",
            "Spikes have adjustable touchboxes. Flat, Danger, or Tip - choose wisely!",
            "Portal colors can be customized. Color-code your teleport network!",
            "This game was made with love, caffeine, and questionable sleep schedules.",
            "Sometimes the best parkour is knowing when NOT to jump.",
            "Every great map starts with a terrible first draft.",
            "If you're stuck, try looking at the problem from a different angle. Literally.",
            "The best speedrunners know every pixel. Do you?",
            "Fun fact: The developer tested this loading screen way too many times.",
            "Remember: Frustration is just delayed satisfaction.",
            "Pro tip: Blame the spikes, not yourself.",
            "Have you tried turning the gravity off and on again?",
            "Your map could be someone's favorite. Keep building!",
            "The finish line is just the beginning of another run."
        ];
        
        let hintInterval = null;
        let currentHintIndex = -1;
        
        function getRandomHint() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * loadingHints.length);
            } while (newIndex === currentHintIndex && loadingHints.length > 1);
            currentHintIndex = newIndex;
            return loadingHints[newIndex];
        }
        
        function showHint() {
            const hintEl = document.getElementById('loading-hint');
            if (!hintEl) return;
            
            // Fade out
            hintEl.classList.add('fade-out');
            
            setTimeout(() => {
                // Change text
                hintEl.textContent = 'üí° ' + getRandomHint();
                // Fade in
                hintEl.classList.remove('fade-out');
            }, 500);
        }
        
        function startHintCycle() {
            const hintEl = document.getElementById('loading-hint');
            if (!hintEl) return;
            
            // Show first hint immediately (no fade)
            hintEl.textContent = 'üí° ' + getRandomHint();
            
            // Cycle every 8 seconds
            hintInterval = setInterval(showHint, 8000);
        }
        
        function stopHintCycle() {
            if (hintInterval) {
                clearInterval(hintInterval);
                hintInterval = null;
            }
        }

        // Resource Loading Manager with accurate progress tracking (dual progress bars)
        const resourceLoader = {
            // Total progress (green bar) - tracks ALL resources
            totalLoaded: 0,
            totalSize: 0,
            // Part progress (orange bar) - tracks current category
            partLoaded: 0,
            partSize: 0,
            currentPart: '',
            // Resource sizes cache (calculated upfront)
            resourceSizes: {},
            
            updateTotalUI() {
                const progressBar = document.getElementById('loading-progress-total');
                const sizeEl = document.getElementById('loading-size-total');
                
                const percent = this.totalSize > 0 ? Math.min(100, (this.totalLoaded / this.totalSize) * 100) : 0;
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                }
                
                if (sizeEl) {
                    const loadedMB = (this.totalLoaded / 1024 / 1024).toFixed(2);
                    const totalMB = (this.totalSize / 1024 / 1024).toFixed(2);
                    sizeEl.textContent = `${loadedMB} MB / ${totalMB} MB (${Math.round(percent)}%)`;
                }
            },
            
            updatePartUI() {
                const progressBar = document.getElementById('loading-progress-part');
                const labelEl = document.getElementById('loading-label-part');
                const sizeEl = document.getElementById('loading-size-part');
                
                if (labelEl) labelEl.textContent = `Current: ${this.currentPart}`;
                
                const percent = this.partSize > 0 ? Math.min(100, (this.partLoaded / this.partSize) * 100) : 0;
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                }
                
                if (sizeEl && this.partSize > 0) {
                    const loadedKB = (this.partLoaded / 1024).toFixed(1);
                    const totalKB = (this.partSize / 1024).toFixed(1);
                    sizeEl.textContent = `${loadedKB} KB / ${totalKB} KB (${Math.round(percent)}%)`;
                } else if (sizeEl) {
                    sizeEl.textContent = '';
                }
            },
            
            startPart(name, resources) {
                this.currentPart = name;
                this.partLoaded = 0;
                // Calculate part size from pre-fetched sizes
                this.partSize = resources.reduce((sum, src) => sum + (this.resourceSizes[src] || 0), 0);
                this.updatePartUI();
            },
            
            async getFileSize(src) {
                try {
                    const res = await fetch(src, { method: 'HEAD' });
                    return parseInt(res.headers.get('content-length') || '50000');
                } catch {
                    return 50000; // Default estimate
                }
            },
            
            // Pre-fetch all file sizes to know total upfront
            async calculateAllSizes(allResources) {
                this.currentPart = 'Calculating...';
                this.updatePartUI();
                
                const sizes = await Promise.all(
                    allResources.map(async (src) => {
                        const size = await this.getFileSize(src);
                        this.resourceSizes[src] = size;
                        return size;
                    })
                );
                
                this.totalSize = sizes.reduce((sum, size) => sum + size, 0);
                this.updateTotalUI();
            },
            
            async preloadImage(src) {
                const size = this.resourceSizes[src] || 50000;
                
                return new Promise((resolve) => {
                    let resolved = false;
                    
                    const markLoaded = (img) => {
                        if (resolved) return;
                        resolved = true;
                        this.partLoaded += size;
                        this.totalLoaded += size;
                        this.updatePartUI();
                        this.updateTotalUI();
                        resolve(img);
                    };
                    
                    const img = new Image();
                    img.onload = () => markLoaded(img);
                    img.onerror = () => markLoaded(null);
                    img.src = src;
                });
            },
            
            async preloadAudio(src) {
                const size = this.resourceSizes[src] || 50000;
                
                return new Promise((resolve) => {
                    let resolved = false;
                    
                    const markLoaded = (audio) => {
                        if (resolved) return;
                        resolved = true;
                        this.partLoaded += size;
                        this.totalLoaded += size;
                        this.updatePartUI();
                        this.updateTotalUI();
                        resolve(audio);
                    };
                    
                    const audio = new Audio();
                    audio.addEventListener('canplaythrough', () => markLoaded(audio), { once: true });
                    audio.onerror = () => markLoaded(null);
                    // Timeout in case canplaythrough never fires
                    setTimeout(() => markLoaded(audio), 5000);
                    audio.src = src;
                    audio.load();
                });
            },
            
            // Preload audio and return the Audio object for reuse
            async preloadAudioAndReturn(src) {
                const size = this.resourceSizes[src] || 50000;
                
                return new Promise((resolve) => {
                    let resolved = false;
                    
                    const markLoaded = (audio, success) => {
                        if (resolved) return;
                        resolved = true;
                        this.partLoaded += size;
                        this.totalLoaded += size;
                        this.updatePartUI();
                        this.updateTotalUI();
                        resolve(success ? audio : null);
                    };
                    
                    const audio = new Audio();
                    audio.addEventListener('canplaythrough', () => markLoaded(audio, true), { once: true });
                    audio.onerror = () => markLoaded(null, false);
                    // Timeout - return audio anyway (may still work)
                    setTimeout(() => markLoaded(audio, true), 5000);
                    audio.src = src;
                    audio.load();
                });
            },
            
            async loadAll(pluginResources = []) {
                this.totalLoaded = 0;
                this.totalSize = 0;
                this.partLoaded = 0;
                this.partSize = 0;
                this.resourceSizes = {};
                this.updateTotalUI();
                this.updatePartUI();
                
                // Start hint cycle
                startHintCycle();
                
                // Define resources to preload - split into more granular categories
                const uiImages = [
                    'assets/png/logo.png',
                    'assets/png/cover.png'
                ];
                
                const gameSprites = [
                    'assets/svg/spike-64x.svg',
                    'assets/svg/portal-64x.svg'
                ];
                
                const sfx = [
                    'assets/mp3/jump.mp3'
                ];
                
                const music = [
                    'assets/mp3/maccary-bay.mp3',
                    'assets/mp3/reggae-party.mp3'
                ];
                
                // Step 1: Calculate ALL sizes upfront (core + plugins) so we know the true total
                const allResources = [...uiImages, ...gameSprites, ...sfx, ...music, ...pluginResources];
                await this.calculateAllSizes(allResources);
                
                // Step 2: Load UI images
                this.startPart('Loading UI...', uiImages);
                for (const src of uiImages) {
                    await this.preloadImage(src);
                }
                
                // Step 3: Load game sprites
                this.startPart('Loading Sprites...', gameSprites);
                for (const src of gameSprites) {
                    await this.preloadImage(src);
                }
                
                // Step 4: Load sound effects
                this.startPart('Loading SFX...', sfx);
                for (const src of sfx) {
                    await this.preloadAudio(src);
                }
                
                // Step 5: Load music
                this.startPart('Loading Music...', music);
                for (const src of music) {
                    await this.preloadAudio(src);
                }
                
                // Core resources complete - plugins will be loaded next if any
                this.currentPart = 'Core resources loaded';
                this.updatePartUI();
                
                return true;
            },
            
            // Simple status update (for post-resource loading phases)
            updateProgress(status) {
                const labelEl = document.getElementById('loading-label-part');
                if (labelEl) labelEl.textContent = `Current: ${status}`;
                
                // Set part bar to 100% for non-tracked phases
                const progressBar = document.getElementById('loading-progress-part');
                if (progressBar) progressBar.style.width = '100%';
                
                const sizeEl = document.getElementById('loading-size-part');
                if (sizeEl) sizeEl.textContent = '';
            },
            
            // Load a script file with progress tracking
            async preloadScript(src) {
                const size = this.resourceSizes[src] || 50000;
                
                return new Promise((resolve) => {
                    let resolved = false;
                    
                    const markLoaded = (success) => {
                        if (resolved) return;
                        resolved = true;
                        this.partLoaded += size;
                        this.totalLoaded += size;
                        this.updatePartUI();
                        this.updateTotalUI();
                        resolve(success);
                    };
                    
                    // Check if script already exists
                    if (document.querySelector(`script[src="${src}"]`)) {
                        markLoaded(true);
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = () => markLoaded(true);
                    script.onerror = () => markLoaded(false);
                    document.head.appendChild(script);
                });
            },
            
            // Fetch a script as text with progress tracking
            async preloadScriptText(src) {
                const size = this.resourceSizes[src] || 10000;
                
                try {
                    const response = await fetch(src);
                    const text = response.ok ? await response.text() : null;
                    
                    this.partLoaded += size;
                    this.totalLoaded += size;
                    this.updatePartUI();
                    this.updateTotalUI();
                    
                    return text;
                } catch (e) {
                    this.partLoaded += size;
                    this.totalLoaded += size;
                    this.updatePartUI();
                    this.updateTotalUI();
                    return null;
                }
            },
            
            // Add more resources to total (for plugins discovered after initial calculation)
            async addToTotal(resources) {
                for (const src of resources) {
                    if (!this.resourceSizes[src]) {
                        const size = await this.getFileSize(src);
                        this.resourceSizes[src] = size;
                        this.totalSize += size;
                    }
                }
                this.updateTotalUI();
            },
            
            hide() {
                // Stop hint cycle
                stopHintCycle();
                
                const overlay = document.getElementById('loading-overlay');
                if (overlay) {
                    overlay.classList.add('hidden');
                    setTimeout(() => {
                        overlay.remove();
                    }, 500);
                }
            }
        };

        document.addEventListener('DOMContentLoaded', async () => {
            // Check auth
            if (!Auth.requireAuth()) return;

            // Parse URL params
            const params = new URLSearchParams(window.location.search);
            currentMapId = params.get('map');
            currentMode = params.get('mode') || 'edit';
            const roomCode = params.get('room');

            // Step 1: Pre-fetch map data to know which plugins need loading
            let mapData = null;
            let enabledPlugins = [];
            
            if (currentMapId) {
                resourceLoader.updateProgress('Fetching map info...');
                try {
                    const getMapFn = window.MapManager.getMap;
                    mapData = await getMapFn.call(window.MapManager, currentMapId);
                    // Extract enabled plugins from map data
                    if (mapData?.data?.plugins?.enabled) {
                        enabledPlugins = mapData.data.plugins.enabled;
                    }
                } catch (e) {
                    console.warn('[Preload] Could not fetch map data:', e);
                }
            } else if (currentMode === 'play' && roomCode) {
                // Check session storage for play mode
                const gameData = sessionStorage.getItem('parkoreen_game');
                if (gameData) {
                    try {
                        const data = JSON.parse(gameData);
                        if (data.mapData?.plugins?.enabled) {
                            enabledPlugins = data.mapData.plugins.enabled;
                        }
                    } catch (e) {
                        console.warn('[Preload] Could not parse game data:', e);
                    }
                }
            }
            
            // Step 2: Discover plugins FIRST to know all resources upfront
            let allPluginResources = [];
            if (window.PluginManager && enabledPlugins.length > 0) {
                resourceLoader.updateProgress('Discovering plugins...');
                await window.PluginManager.discoverPlugins();
                
                // Collect all plugin resources to include in initial size calculation
                for (const pluginId of enabledPlugins) {
                    const scriptUrls = window.PluginManager.getPluginScriptUrls(pluginId);
                    const soundUrls = window.PluginManager.getPluginSoundUrls(pluginId);
                    allPluginResources.push(...scriptUrls, ...soundUrls);
                }
            }
            
            // Step 3: Preload core resources (pass plugin resources for accurate total calculation)
            resourceLoader.updateProgress('Calculating sizes...');
            await resourceLoader.loadAll(allPluginResources);
            
            // Step 4: Load plugins with progress tracking (sizes already calculated)
            if (window.PluginManager && enabledPlugins.length > 0) {
                for (const pluginId of enabledPlugins) {
                    const plugin = window.PluginManager.plugins.get(pluginId);
                    if (!plugin || window.PluginManager.loadedScripts.has(pluginId)) continue;
                    
                    const scriptUrls = window.PluginManager.getPluginScriptUrls(pluginId);
                    const soundUrls = window.PluginManager.getPluginSoundUrls(pluginId);
                    const pluginResources = [...scriptUrls, ...soundUrls];
                    
                    // Start part tracking for this plugin
                    resourceLoader.startPart(`Plugin: ${plugin.name || pluginId}`, pluginResources);
                    
                    try {
                        // Load library scripts (as script tags)
                        const libraryScripts = ['skulpt', 'skulptStdlib', 'pythonCompiler'];
                        for (const scriptName of libraryScripts) {
                            if (plugin.scripts?.[scriptName]) {
                                const src = plugin.path + plugin.scripts[scriptName];
                                await resourceLoader.preloadScript(src);
                            }
                        }
                        
                        // Load text scripts (globals, inject, script)
                        const scripts = {};
                        if (plugin.scripts?.globals) {
                            scripts.globals = await resourceLoader.preloadScriptText(plugin.path + plugin.scripts.globals);
                        }
                        if (plugin.scripts?.inject) {
                            scripts.inject = await resourceLoader.preloadScriptText(plugin.path + plugin.scripts.inject);
                        }
                        if (plugin.scripts?.script) {
                            scripts.script = await resourceLoader.preloadScriptText(plugin.path + plugin.scripts.script);
                        }
                        
                        // Load editor script (as script tag)
                        if (plugin.scripts?.editor) {
                            await resourceLoader.preloadScript(plugin.path + plugin.scripts.editor);
                        }
                        
                        // Store loaded scripts in plugin manager
                        window.PluginManager.loadedScripts.set(pluginId, scripts);
                        
                        // Load sounds with progress tracking
                        // This also stores the audio objects for reuse
                        if (plugin.sounds) {
                            const sounds = {};
                            for (const [name, path] of Object.entries(plugin.sounds)) {
                                if (Array.isArray(path)) {
                                    sounds[name] = [];
                                    for (const p of path) {
                                        const audio = await resourceLoader.preloadAudioAndReturn(plugin.path + p);
                                        if (audio) {
                                            audio.volume = 1;
                                            sounds[name].push(audio);
                                        }
                                    }
                                } else {
                                    const audio = await resourceLoader.preloadAudioAndReturn(plugin.path + path);
                                    if (audio) {
                                        audio.volume = 1;
                                        if (name === 'superdashFlying') {
                                            audio.loop = true;
                                        }
                                        sounds[name] = audio;
                                    }
                                }
                            }
                            window.PluginManager.sounds.set(pluginId, sounds);
                        }
                    } catch (e) {
                        console.warn(`[Preload] Failed to load plugin ${pluginId}:`, e);
                    }
                }
            }

            // Step 4: Initialize game engine
            resourceLoader.updateProgress('Initializing game engine...');
            engine = new GameEngine('game-canvas');
            window.engine = engine; // Expose globally for plugins
            engine.start();

            // Step 5: Initialize editor
            resourceLoader.updateProgress('Setting up editor...');
            editor = new Editor(engine);
            editor.initUI();
            editor.updateBackground();
            
            // Create editor player (fly mode, camera follows, no death)
            engine.createEditorPlayer();
            
            // Set initial favicon based on mode
            if (currentMode === 'edit') {
                setFavicon('editor');
            } else {
                setFavicon('play');
            }

            // Step 6: Load map or game data (plugins already loaded, just need to enable them)
            if (currentMode === 'play' && roomCode) {
                // Join existing game
                resourceLoader.updateProgress('Joining game...');
                await initializePlayMode(roomCode);
            } else if (currentMapId) {
                // Load map for editing or hosting
                resourceLoader.updateProgress('Applying map data...');
                if (mapData) {
                    // Use pre-fetched data (plugins already loaded in preload phase)
                    await loadMapWithData(currentMapId, mapData);
                } else {
                    // Fallback: fetch and load (if pre-fetch failed)
                await loadMap(currentMapId);
                }
                
                if (currentMode === 'host') {
                    // Directly start hosting after map is loaded
                    setTimeout(() => {
                        if (editor && editor.hostGame) {
                            editor.hostGame();
                        }
                    }, 500);
                }
            } else {
                // New map - no existing data to corrupt
                engine.world.mapName = 'New Map';
                mapLoadedSuccessfully = true;
            }

            // Setup event handlers
            setupGameHUD();
            setupMultiplayer();
            setupEndGameScreen();
            
            // Setup auto-save for editor mode
            if (currentMapId) {
                console.log('[AutoSave] Setting up auto-save for map:', currentMapId);
                
                // Auto-save every 30 seconds
                setInterval(async () => {
                    if (engine && engine.state === GameState.EDITOR) {
                        console.log('[AutoSave] Interval save (30s)...');
                        await saveMap();
                    }
                }, 30000);
                
                // Setup save-on-change callback
                editor.onMapChange = debounce(async () => {
                    if (engine && engine.state === GameState.EDITOR) {
                        console.log('[AutoSave] Change detected, saving...');
                        await saveMapSilent();
                    }
                }, 2000); // Debounce: wait 2 seconds after last change before saving
                
                // Setup save-before-test callback
                editor.onBeforeTest = async () => {
                    console.log('[AutoSave] Saving before test...');
                    await saveMapSilent();
                };
            }
            
            // Hide loading screen after everything is ready
            // Ensure total bar shows 100%
            resourceLoader.totalLoaded = resourceLoader.totalSize;
            resourceLoader.updateTotalUI();
            resourceLoader.updateProgress('Ready!');
            setTimeout(() => {
                resourceLoader.hide();
            }, 300);
        });
        
        // Silent save (no toast) for auto-save on change
        async function saveMapSilent() {
            if (!currentMapId) return;
            if (!mapLoadedSuccessfully) {
                console.warn('[AutoSave] Skipping save - map was not loaded successfully');
                return;
            }
            try {
                const data = engine.world.toJSON();
                var saveFn = window.MapManager.saveMap;
                await saveFn.call(window.MapManager, currentMapId, { data });
                console.log('[AutoSave] Saved silently');
            } catch (error) {
                console.error('[AutoSave] Silent save failed:', error);
            }
        }
        
        // Debounce utility
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Load map using pre-fetched data (plugins already loaded in preload phase)
        async function loadMapWithData(mapId, prefetchedData) {
            try {
                if (prefetchedData && prefetchedData.data) {
                    engine.world.fromJSON(prefetchedData.data);
                }
                engine.world.mapName = prefetchedData?.name || 'Untitled Map';
                
                // Initialize plugins from world data (scripts already loaded in preload)
                if (window.PluginManager) {
                    await window.PluginManager.initFromWorld(engine.world);
                }
                
                // Recreate editor player at spawn point
                engine.createEditorPlayer();
                
                editor.updateBackground();
                
                // Map loaded successfully - allow saving
                mapLoadedSuccessfully = true;
                toastSuccess('Map loaded!');
            } catch (parseError) {
                // Parse/corruption error - show popup
                mapLoadedSuccessfully = false;
                console.error('[LoadMap] Save corrupted:', parseError);
                showSaveCorruptedPopup();
            }
        }
        
        // Legacy function for cases where data needs to be fetched
        async function loadMap(mapId) {
            let mapData = null;
            
            // Step 1: Try to fetch the map from storage
            try {
                loadingShow('Loading map...');
                var getMapFn = window.MapManager.getMap;
                mapData = await getMapFn.call(window.MapManager, mapId);
            } catch (networkError) {
                // Network error - don't allow saving to prevent data loss
                loadingHide();
                mapLoadedSuccessfully = false;
                toastError('Failed to load map (network error): ' + networkError.message);
                console.error('[LoadMap] Network error, saving disabled:', networkError);
                return;
            }
            
            // Step 2: Try to parse/deserialize the map data
            try {
                if (mapData && mapData.data) {
                    engine.world.fromJSON(mapData.data);
                }
                engine.world.mapName = mapData?.name || 'Untitled Map';
                
                // Initialize plugins from world data
                if (window.PluginManager) {
                    await window.PluginManager.discoverPlugins();
                    await window.PluginManager.initFromWorld(engine.world);
                }
                
                // Recreate editor player at spawn point
                engine.createEditorPlayer();
                
                editor.updateBackground();
                loadingHide();
                
                // Map loaded successfully - allow saving
                mapLoadedSuccessfully = true;
                toastSuccess('Map loaded!');
            } catch (parseError) {
                // Parse/corruption error - show popup
                loadingHide();
                mapLoadedSuccessfully = false;
                console.error('[LoadMap] Save corrupted:', parseError);
                showSaveCorruptedPopup();
            }
        }

        async function saveMap() {
            if (!currentMapId) {
                toastError('No map to save');
                return;
            }
            
            if (!mapLoadedSuccessfully) {
                console.warn('[SaveMap] Skipping save - map was not loaded successfully');
                toastError('Cannot save: map failed to load properly');
                return;
            }

            try {
                const data = engine.world.toJSON();
                var saveFn = window.MapManager.saveMap;
                await saveFn.call(window.MapManager, currentMapId, { data });
                toastSuccess('Map saved!');
            } catch (error) {
                toastError('Failed to save map: ' + error.message);
            }
        }

        async function initializePlayMode(roomCode) {
            const gameData = sessionStorage.getItem('parkoreen_game');
            if (gameData) {
                const data = JSON.parse(gameData);
                if (data.mapData) {
                    engine.world.fromJSON(data.mapData);
                    // Update background based on map theme
                    editor.updateBackground();
                    
                    // Initialize plugins from world data (scripts already loaded in preload phase)
                    if (window.PluginManager) {
                        await window.PluginManager.initFromWorld(engine.world);
                    }
                }
                isHost = data.isHost || false;
            }

            // Hide editor UI
            document.getElementById('editor-ui')?.classList.add('hidden');
            document.getElementById('toolbar')?.classList.add('hidden');

            // Show game HUD
            document.getElementById('game-hud').classList.remove('hidden');
            
            // Show room code
            if (roomCode) {
                const roomCodeDisplay = document.getElementById('room-code-display');
                roomCodeDisplay.innerHTML = '<span style="font-size: 0.9rem; opacity: 0.8; letter-spacing: 1px;">Game Code:</span> ' + roomCode;
                roomCodeDisplay.classList.remove('hidden');
            }

            // Start game with user's persistent color
            const user = Auth.getUser();
            engine.startGame(user.name, user.color);

            // Setup touch controls if enabled
            if (Settings.get('touchscreenMode')) {
                editor.updateTouchControls();
            }
            
            // Start music playback
            if (editor && editor.startMusicPlayback) {
                editor.startMusicPlayback();
            }

            // Reconnect to multiplayer for this room
            await reconnectToRoom(roomCode);
            
            // Start position update loop
            startPositionUpdates();
        }
        
        async function reconnectToRoom(roomCode) {
            const mp = window.MultiplayerManager;
            if (!mp) {
                console.log('[Play] MultiplayerManager not available');
                return;
            }
            
            try {
                // Connect to WebSocket
                await mp.connect();
                
                // Wait for authentication
                await mp.waitForAuth();
                
                console.log('[Play] Reconnected to multiplayer, rejoining room:', roomCode);
                
                // Rejoin the room (server should recognize this session)
                mp.send({
                    type: 'rejoin_room',
                    roomCode: roomCode
                });
            } catch (error) {
                console.error('[Play] Failed to reconnect:', error);
                toastError('Failed to connect to multiplayer: ' + error.message);
            }
        }
        
        // Server reconciliation threshold (1.5 blocks = 48 pixels)
        const RECONCILIATION_THRESHOLD = 1.5 * 32; // 48 pixels
        
        // Track last sent position to avoid sending redundant updates
        let lastSentPosition = { x: 0, y: 0, vx: 0, vy: 0, jumps: 1 };
        
        function startPositionUpdates() {
            setInterval(() => {
                const mp = window.MultiplayerManager;
                if (engine.localPlayer && mp && mp.sendPosition && currentMode === 'play') {
                    const player = engine.localPlayer;
                    
                    // Only send if position or velocity changed significantly
                    const posChanged = Math.abs(player.x - lastSentPosition.x) > 1 ||
                                       Math.abs(player.y - lastSentPosition.y) > 1 ||
                                       Math.abs((player.vx || 0) - lastSentPosition.vx) > 0.5 ||
                                       Math.abs((player.vy || 0) - lastSentPosition.vy) > 0.5 ||
                                       player.jumpsRemaining !== lastSentPosition.jumps;
                    
                    if (posChanged) {
                        lastSentPosition.x = player.x;
                        lastSentPosition.y = player.y;
                        lastSentPosition.vx = player.vx || 0;
                        lastSentPosition.vy = player.vy || 0;
                        lastSentPosition.jumps = player.jumpsRemaining || 1;
                        
                    mp.sendPosition(
                            player.x, 
                            player.y,
                            player.vx || 0,
                            player.vy || 0,
                            player.jumpsRemaining || 1
                    );
                    }
                }
            }, 100); // 10 updates per second (reduced from 20)
        }

        function setupGameHUD() {
            // Leave button
            document.getElementById('hud-leave').addEventListener('click', async () => {
                if (isHost) {
                    let confirmed = false;
                    try {
                        if (window.ModalManager && typeof window.ModalManager.confirm === 'function') {
                            confirmed = await window.ModalManager.confirm(
                        'Leave Room',
                        'Are you sure you want to kick everybody in the room?'
                    );
                        } else {
                            confirmed = confirm('Are you sure you want to kick everybody in the room?');
                        }
                    } catch (e) {
                        confirmed = confirm('Are you sure you want to kick everybody in the room?');
                    }
                    
                    if (confirmed) {
                        if (window.MultiplayerManager?.leaveRoom) {
                            window.MultiplayerManager.leaveRoom();
                        }
                        Navigation.toDashboard();
                    }
                } else {
                    if (window.MultiplayerManager?.leaveRoom) {
                        window.MultiplayerManager.leaveRoom();
                    }
                    Navigation.toDashboard();
                }
            });

            // Settings button
            document.getElementById('hud-settings').addEventListener('click', () => {
                document.getElementById('settings-panel')?.classList.toggle('active');
            });

            // Chat button
            document.getElementById('hud-chat').addEventListener('click', () => {
                document.getElementById('chat-panel').classList.toggle('active');
            });

            // Players button
            document.getElementById('hud-players').addEventListener('click', () => {
                document.getElementById('players-panel').classList.toggle('active');
                updatePlayersList();
            });

            // Close panels
            document.getElementById('close-players-panel').addEventListener('click', () => {
                document.getElementById('players-panel').classList.remove('active');
            });

            // Chat send
            document.getElementById('chat-send').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    sendChatMessage();
                }
            });
        }

        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (message) {
                if (window.MultiplayerManager?.sendChatMessage) {
                    window.MultiplayerManager.sendChatMessage(message);
                }
                input.value = '';
            }
        }

        function addChatMessage(name, message, color) {
            const container = document.getElementById('chat-messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message';
            messageEl.innerHTML = `
                <span class="chat-message-name" style="color: ${color || '#fff'};">${escapeHtml(name)}:</span>
                <span>${escapeHtml(message)}</span>
            `;
            container.appendChild(messageEl);
            container.scrollTop = container.scrollHeight;
        }

        function updatePlayersList() {
            const container = document.getElementById('players-list');
            const players = window.MultiplayerManager?.getPlayers?.() || [];
            
            container.innerHTML = '';
            
            players.forEach(player => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <div class="player-color" style="background: ${player.color}"></div>
                    <span class="player-name">${escapeHtml(player.name)}</span>
                    ${isHost ? `
                        <button class="layer-btn" data-kick="${player.id}" title="Kick Player">
                            <span class="material-symbols-outlined">person_remove</span>
                        </button>
                    ` : ''}
                `;

                if (isHost) {
                    item.querySelector('[data-kick]')?.addEventListener('click', () => {
                        if (window.MultiplayerManager?.kickPlayer) {
                            window.MultiplayerManager.kickPlayer(player.id);
                        }
                    });
                }

                container.appendChild(item);
            });
        }

        function setupMultiplayer() {
            // Check if MultiplayerManager is available
            const mp = window.MultiplayerManager;
            if (!mp || typeof mp.on !== 'function') {
                console.log('[Multiplayer] MultiplayerManager not available, skipping setup');
                return;
            }
            
            // Player joined
            mp.on('playerJoined', (data) => {
                engine.addRemotePlayer(data.playerId, data.playerName, data.playerColor, 0, 0);
                addChatMessage('System', `${data.playerName} joined the parky!`, '#4CAF50');
                updatePlayersList();
            });

            // Player left
            mp.on('playerLeft', (data) => {
                engine.removeRemotePlayer(data.playerId);
                addChatMessage('System', `${data.playerName} left the parky.`, '#f44336');
                updatePlayersList();
            });

            // Player position update
            mp.on('playerPosition', (data) => {
                engine.updateRemotePlayer(data.playerId, data.x, data.y, data.vx || 0, data.vy || 0);
            });
            
            // Position acknowledgment disabled - was causing lag

            // Chat message
            mp.on('chatMessage', (data) => {
                addChatMessage(data.playerName, data.message, data.playerColor);
            });

            // Kicked
            mp.on('kicked', async () => {
                await ModalManager.alert('You Are Kicked!', "Looks like the host doesn't want you to be in here anymore :(");
                Navigation.toDashboard();
            });

            // Room closed
            mp.on('roomClosed', async () => {
                await ModalManager.alert('Uh Oh', 'The host has left the parky :(');
                Navigation.toDashboard();
            });

            // Game end
            mp.on('gameEnd', (data) => {
                ModalManager.alert('Game Over!', `${data.winnerName} has reached the finish line!`);
            });
            
            // Room rejoined (after page reload)
            mp.on('roomRejoined', (data) => {
                console.log('[Multiplayer] Rejoined room:', data.roomCode);
                isHost = data.isHost;
                // Add existing players to the game
                if (data.players) {
                    data.players.forEach(p => {
                        engine.addRemotePlayer(p.id, p.name, p.color, 0, 0);
                    });
                }
                updatePlayersList();
                toastSuccess('Reconnected to room!');
            });
        }

        // Override editor's host game function
        if (typeof Editor !== 'undefined') {
            Editor.prototype.hostGame = async function() {
                // Validate
                if (!this.world.spawnPoint) {
                    this.showToast('Please add a spawn point first!', 'error');
                    return;
                }

                const usePassword = document.getElementById('config-use-password').checked;
                const password = document.getElementById('config-password').value;
                const maxPlayers = parseInt(document.getElementById('config-max-players')?.value) || 10;

                if (usePassword && !password) {
                    this.showToast('Please enter a password or disable password protection.', 'error');
                    return;
                }

                try {
                    loadingShow('Creating room...');

                    // Save map first
                    if (currentMapId) {
                        await saveMap();
                    }

                    const mapData = this.world.toJSON();
                    const mp = window.MultiplayerManager;
                    
                    if (!mp) {
                        throw new Error('Multiplayer not available');
                    }

                    // Setup event handlers before hosting
                    mp.on('roomCreated', (data) => {
                        loadingHide();
                        console.log('[Host] Room created:', data.roomCode);
                        
                        // Store game data in session storage
                        sessionStorage.setItem('parkoreen_game', JSON.stringify({
                            roomCode: data.roomCode,
                            mapData: mapData,
                            isHost: true
                        }));
                        
                        // Enter play mode
                        startHostedGame(data.roomCode, mapData);
                    });

                    mp.on('error', (data) => {
                        loadingHide();
                        toastError('Failed to create room: ' + data.message);
                    });

                    // Create room on server
                    await mp.hostGame({
                        mapData: mapData,
                        maxPlayers: maxPlayers,
                        usePassword: usePassword,
                        password: usePassword ? password : null
                    });
                    
                } catch (error) {
                    loadingHide();
                    toastError('Failed to host game: ' + error.message);
                }
            };
        }
        
        // Start a hosted game session
        async function startHostedGame(roomCode, mapData) {
            currentMode = 'play';
            isHost = true;
            
            // Switch to play icon
            setFavicon('play');
            
            // Hide editor UI
            document.getElementById('editor-ui')?.classList.add('hidden');
            document.getElementById('toolbar')?.classList.add('hidden');
            
            // Close config panel
            editor.closePanel('config');
            
            // Show game HUD
            document.getElementById('game-hud').classList.remove('hidden');
            
            // Show room code display
            const roomCodeDisplay = document.getElementById('room-code-display');
            roomCodeDisplay.innerHTML = '<span style="font-size: 0.9rem; opacity: 0.8; letter-spacing: 1px;">Game Code:</span> ' + roomCode;
            roomCodeDisplay.classList.remove('hidden');
            
            // Start the game with user's persistent color
            const user = Auth.getUser();
            engine.startGame(user.name, user.color);
            
            // Setup touch controls if enabled
            if (Settings.get('touchscreenMode')) {
                editor.updateTouchControls();
            }
            
            // Start music playback
            if (editor && editor.startMusicPlayback) {
                editor.startMusicPlayback();
            }
            
            // Start sending position updates
            startPositionUpdates();
            
            toastSuccess('Room created! Share the code: ' + roomCode);
        }

        // Save on page visibility change (user switches tabs)
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden && currentMapId && engine && engine.state === GameState.EDITOR) {
                console.log('[AutoSave] Tab hidden, saving...');
                await saveMap();
            }
        });

        // Save on page unload (user closes tab or navigates away)
        window.addEventListener('beforeunload', (e) => {
            if (currentMapId && engine && engine.state === GameState.EDITOR && mapLoadedSuccessfully) {
                // Use synchronous save for local mode
                try {
                    const data = engine.world.toJSON();
                    // Try to save synchronously to local storage
                    const maps = JSON.parse(localStorage.getItem('parkoreen_local_maps_' + (Auth.getUser()?.id || 'guest')) || '{}');
                    if (maps[currentMapId]) {
                        maps[currentMapId].data = data;
                        maps[currentMapId].updatedAt = new Date().toISOString();
                        localStorage.setItem('parkoreen_local_maps_' + (Auth.getUser()?.id || 'guest'), JSON.stringify(maps));
                        console.log('[AutoSave] Saved on unload');
                    }
                } catch (err) {
                    console.error('[AutoSave] Failed to save on unload:', err);
                }
            } else if (currentMapId && !mapLoadedSuccessfully) {
                console.warn('[AutoSave] Skipping unload save - map was not loaded successfully');
            }
        });

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        let lastEndGameData = null;

        function setupEndGameScreen() {
            // Set up the game end callback
            engine.onGameEndCallback = (data) => {
                showEndGameScreen(data);
                
                // If in multiplayer, notify other players
                if (window.MultiplayerManager && window.MultiplayerManager.send && currentMode === 'play') {
                    window.MultiplayerManager.send({
                        type: 'game_end',
                        playerName: data.playerName,
                        time: data.time
                    });
                }
            };

            // Play Again button
            document.getElementById('end-game-play-again').addEventListener('click', () => {
                hideEndGameScreen();
                
                // Restart the game
                if (lastEndGameData && lastEndGameData.wasTestMode) {
                    // Restart test mode
                    engine.startTestGame();
                    if (editor && editor.startMusicPlayback) {
                        editor.startMusicPlayback();
                    }
                } else {
                    // Restart play mode
                    const user = Auth.getUser();
                    engine.startGame(user.name, user.color);
                    if (editor && editor.startMusicPlayback) {
                        editor.startMusicPlayback();
                    }
                }
            });

            // Back to Editor button
            document.getElementById('end-game-back').addEventListener('click', () => {
                hideEndGameScreen();
                
                if (currentMode === 'play') {
                    // Leave the multiplayer room
                    if (window.MultiplayerManager?.leaveRoom) {
                        window.MultiplayerManager.leaveRoom();
                    }
                    Navigation.toDashboard();
                } else {
                    // Stop testing and return to editor
                    editor.stopTest();
                }
            });
        }
        
        function showEndGameScreen(data) {
            lastEndGameData = data;
            const overlay = document.getElementById('end-game-overlay');
            const timeValue = document.getElementById('end-game-time');
            const playerName = document.getElementById('end-game-player');
            const backBtn = document.getElementById('end-game-back');
            
            // Set the time
            timeValue.textContent = data.time || '0:00.000';
            
            // Set player name
            playerName.textContent = data.playerName || 'Player';
            
            // Update button text based on mode
            if (data.wasTestMode) {
                backBtn.innerHTML = '<span class="material-symbols-outlined">edit</span> Back to Editor';
            } else {
                backBtn.innerHTML = '<span class="material-symbols-outlined">arrow_back</span> Leave Game';
            }
            
            // Show the overlay
            overlay.classList.remove('hidden');
        }

        function hideEndGameScreen() {
            const overlay = document.getElementById('end-game-overlay');
            overlay.classList.add('hidden');
        }
    </script>
</body>
</html>
